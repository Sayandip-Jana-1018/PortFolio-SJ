import { Project } from './projectsData';

export const additionalProjects: Project[] = [
  {
    title: 'SmartHome Hub',
    description: 'A comprehensive IoT platform for smart home management, allowing users to control and automate their home devices, monitor energy usage, and enhance home security through a unified interface.',
    image: '/projects/project3.png',
    technologies: ['React Native', 'Node.js', 'MQTT', 'MongoDB', 'WebSockets'],
    github: 'https://github.com/yourusername/smarthome-hub',
    live: 'https://smarthome-hub.vercel.app',
    category: 'IoT',
    codeSnippet: [
      'const mqtt = require("mqtt");',
      'const EventEmitter = require("events");',
      '',
      'class MqttController extends EventEmitter {',
      '  constructor(config) {',
      '    super();',
      '    this.config = config;',
      '    this.client = null;',
      '    this.isConnected = false;',
      '    this.topicHandlers = new Map();',
      '    this.deviceCache = new Map();',
      '    this.automationRules = [];',
      '  }',
      '',
      '  connect() {',
      '    return new Promise((resolve, reject) => {',
      '      const { brokerUrl, username, password, clientId } = this.config;',
      '      ',
      '      this.client = mqtt.connect(brokerUrl, {',
      '        username,',
      '        password,',
      '        clientId: clientId || `smarthome_${Math.random().toString(16).substr(2, 8)}`,',
      '        clean: true,',
      '        reconnectPeriod: 5000',
      '      });',
      '',
      '      this.client.on("connect", () => {',
      '        console.log("Connected to MQTT broker");',
      '        this.isConnected = true;',
      '        this.emit("connected");',
      '        ',
      '        // Subscribe to all registered topics',
      '        for (const topic of this.topicHandlers.keys()) {',
      '          this.client.subscribe(topic, (err) => {',
      '            if (err) {',
      '              console.error(`Error subscribing to ${topic}:`, err);',
      '            } else {',
      '              console.log(`Subscribed to ${topic}`);',
      '            }',
      '          });',
      '        }',
      '        ',
      '        resolve();',
      '      });',
      '',
      '      this.client.on("message", (topic, message) => {',
      '        const payload = message.toString();',
      '        console.log(`Message received on ${topic}: ${payload}`);',
      '        ',
      '        try {',
      '          const data = JSON.parse(payload);',
      '          ',
      '          // Update device cache if this is a device state update',
      '          if (topic.includes("/state")) {',
      '            const deviceId = topic.split("/")[1];',
      '            this.deviceCache.set(deviceId, {',
      '              ...this.deviceCache.get(deviceId),',
      '              ...data,',
      '              lastUpdated: new Date()',
      '            });',
      '          }',
      '          ',
      '          // Process through automation rules',
      '          this.processAutomationRules(topic, data);',
      '          ',
      '          // Call registered handlers for this topic',
      '          const handlers = this.topicHandlers.get(topic) || [];',
      '          handlers.forEach(handler => handler(data, topic));',
      '          ',
      '          // Emit a generic message event',
      '          this.emit("message", { topic, data });',
      '        } catch (err) {',
      '          console.error(`Error processing message on ${topic}:`, err);',
      '        }',
      '      });',
      '',
      '      this.client.on("error", (err) => {',
      '        console.error("MQTT connection error:", err);',
      '        this.emit("error", err);',
      '        reject(err);',
      '      });',
      '',
      '      this.client.on("disconnect", () => {',
      '        console.log("Disconnected from MQTT broker");',
      '        this.isConnected = false;',
      '        this.emit("disconnected");',
      '      });',
      '    });',
      '  }',
      '',
      '  subscribe(topic, handler) {',
      '    if (!this.topicHandlers.has(topic)) {',
      '      this.topicHandlers.set(topic, []);',
      '      ',
      '      // If already connected, subscribe immediately',
      '      if (this.isConnected) {',
      '        this.client.subscribe(topic, (err) => {',
      '          if (err) {',
      '            console.error(`Error subscribing to ${topic}:`, err);',
      '          } else {',
      '            console.log(`Subscribed to ${topic}`);',
      '          }',
      '        });',
      '      }',
      '    }',
      '    ',
      '    if (handler) {',
      '      this.topicHandlers.get(topic).push(handler);',
      '    }',
      '  }',
      '',
      '  unsubscribe(topic, handler) {',
      '    if (!this.topicHandlers.has(topic)) return;',
      '    ',
      '    if (handler) {',
      '      // Remove specific handler',
      '      const handlers = this.topicHandlers.get(topic);',
      '      const index = handlers.indexOf(handler);',
      '      if (index !== -1) {',
      '        handlers.splice(index, 1);',
      '      }',
      '      ',
      '      // If no handlers left, unsubscribe from topic',
      '      if (handlers.length === 0) {',
      '        this.topicHandlers.delete(topic);',
      '        if (this.isConnected) {',
      '          this.client.unsubscribe(topic);',
      '        }',
      '      }',
      '    } else {',
      '      // Remove all handlers and unsubscribe',
      '      this.topicHandlers.delete(topic);',
      '      if (this.isConnected) {',
      '        this.client.unsubscribe(topic);',
      '      }',
      '    }',
      '  }',
      '',
      '  publish(topic, message) {',
      '    return new Promise((resolve, reject) => {',
      '      if (!this.isConnected) {',
      '        reject(new Error("Not connected to MQTT broker"));',
      '        return;',
      '      }',
      '      ',
      '      const payload = typeof message === "object" ? JSON.stringify(message) : message;',
      '      ',
      '      this.client.publish(topic, payload, (err) => {',
      '        if (err) {',
      '          console.error(`Error publishing to ${topic}:`, err);',
      '          reject(err);',
      '        } else {',
      '          console.log(`Published to ${topic}: ${payload}`);',
      '          resolve();',
      '        }',
      '      });',
      '    });',
      '  }',
      '',
      '  getDeviceState(deviceId) {',
      '    return this.deviceCache.get(deviceId) || null;',
      '  }',
      '',
      '  addAutomationRule(rule) {',
      '    // Rule format: { trigger: { topic, condition }, action: { topic, message } }',
      '    this.automationRules.push(rule);',
      '    ',
      '    // Subscribe to the trigger topic if not already subscribed',
      '    if (!this.topicHandlers.has(rule.trigger.topic)) {',
      '      this.subscribe(rule.trigger.topic);',
      '    }',
      '  }',
      '',
      '  processAutomationRules(topic, data) {',
      '    this.automationRules.forEach(rule => {',
      '      if (rule.trigger.topic === topic) {',
      '        // Check if condition is met',
      '        let conditionMet = true;',
      '        if (rule.trigger.condition) {',
      '          conditionMet = rule.trigger.condition(data);',
      '        }',
      '        ',
      '        if (conditionMet) {',
      '          // Execute the action',
      '          let actionMessage = rule.action.message;',
      '          if (typeof actionMessage === "function") {',
      '            actionMessage = actionMessage(data);',
      '          }',
      '          ',
      '          this.publish(rule.action.topic, actionMessage);',
      '        }',
      '      }',
      '    });',
      '  }',
      '',
      '  disconnect() {',
      '    return new Promise((resolve) => {',
      '      if (this.client && this.isConnected) {',
      '        this.client.end(true, {}, () => {',
      '          this.isConnected = false;',
      '          this.emit("disconnected");',
      '          resolve();',
      '        });',
      '      } else {',
      '        resolve();',
      '      }',
      '    });',
      '  }',
      '}'
    ],
    codeLanguage: 'javascript',
    features: [
      'Unified device control interface',
      'Energy usage monitoring and optimization',
      'Automated routines and scenes',
      'Voice control integration',
      'Security monitoring and alerts'
    ]
  },
  {
    title: 'ArtGallery3D',
    description: 'A virtual 3D art gallery platform that allows artists to showcase their work in immersive virtual environments. Visitors can explore exhibitions, interact with artworks, and purchase pieces directly from artists.',
    image: '/projects/project3.png',
    technologies: ['Three.js', 'WebGL', 'React', 'Node.js', 'Firebase'],
    github: 'https://github.com/yourusername/artgallery3d',
    live: 'https://artgallery3d.vercel.app',
    category: 'Creative',
    codeSnippet: [
      'import * as THREE from "three";',
      'import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";',
      'import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";',
      'import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer";',
      'import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";',
      'import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass";',
      '',
      'class GalleryScene {',
      '  constructor(container) {',
      '    this.container = container;',
      '    this.artworks = [];',
      '    this.raycaster = new THREE.Raycaster();',
      '    this.mouse = new THREE.Vector2();',
      '    this.clock = new THREE.Clock();',
      '    this.selectedArtwork = null;',
      '    this.onArtworkSelected = null;',
      '',
      '    this.init();',
      '  }',
      '',
      '  init() {',
      '    // Create scene',
      '    this.scene = new THREE.Scene();',
      '    this.scene.background = new THREE.Color(0x111111);',
      '    this.scene.fog = new THREE.Fog(0x111111, 10, 50);',
      '',
      '    // Create camera',
      '    this.camera = new THREE.PerspectiveCamera(',
      '      60,',
      '      this.container.clientWidth / this.container.clientHeight,',
      '      0.1,',
      '      100',
      '    );',
      '    this.camera.position.set(0, 1.6, 5);',
      '',
      '    // Create renderer',
      '    this.renderer = new THREE.WebGLRenderer({ antialias: true });',
      '    this.renderer.setPixelRatio(window.devicePixelRatio);',
      '    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);',
      '    this.renderer.shadowMap.enabled = true;',
      '    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;',
      '    this.renderer.outputEncoding = THREE.sRGBEncoding;',
      '    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;',
      '    this.renderer.toneMappingExposure = 1;',
      '    this.container.appendChild(this.renderer.domElement);',
      '',
      '    // Add controls',
      '    this.controls = new OrbitControls(this.camera, this.renderer.domElement);',
      '    this.controls.target.set(0, 1, 0);',
      '    this.controls.enableDamping = true;',
      '    this.controls.dampingFactor = 0.05;',
      '    this.controls.minDistance = 1;',
      '    this.controls.maxDistance = 15;',
      '    this.controls.maxPolarAngle = Math.PI / 2;',
      '',
      '    // Post-processing',
      '    this.composer = new EffectComposer(this.renderer);',
      '    const renderPass = new RenderPass(this.scene, this.camera);',
      '    this.composer.addPass(renderPass);',
      '',
      '    const bloomPass = new UnrealBloomPass(',
      '      new THREE.Vector2(this.container.clientWidth, this.container.clientHeight),',
      '      0.5, // strength',
      '      0.4, // radius',
      '      0.85 // threshold',
      '    );',
      '    this.composer.addPass(bloomPass);',
      '',
      '    // Add lights',
      '    this.addLights();',
      '',
      '    // Load gallery model',
      '    this.loadGalleryModel();',
      '',
      '    // Event listeners',
      '    window.addEventListener("resize", this.onWindowResize.bind(this));',
      '    this.container.addEventListener("click", this.onMouseClick.bind(this));',
      '    this.container.addEventListener("mousemove", this.onMouseMove.bind(this));',
      '',
      '    // Start animation loop',
      '    this.animate();',
      '  }',
      '',
      '  addLights() {',
      '    // Ambient light',
      '    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);',
      '    this.scene.add(ambientLight);',
      '',
      '    // Directional light (sun)',
      '    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);',
      '    dirLight.position.set(5, 10, 5);',
      '    dirLight.castShadow = true;',
      '    dirLight.shadow.mapSize.width = 2048;',
      '    dirLight.shadow.mapSize.height = 2048;',
      '    dirLight.shadow.camera.near = 0.5;',
      '    dirLight.shadow.camera.far = 50;',
      '    dirLight.shadow.camera.left = -10;',
      '    dirLight.shadow.camera.right = 10;',
      '    dirLight.shadow.camera.top = 10;',
      '    dirLight.shadow.camera.bottom = -10;',
      '    this.scene.add(dirLight);',
      '',
      '    // Add spotlights for each artwork',
      '    for (let i = -3; i <= 3; i += 1.5) {',
      '      const spotLight = new THREE.SpotLight(0xffffff, 1);',
      '      spotLight.position.set(i, 3, 0.5);',
      '      spotLight.angle = Math.PI / 6;',
      '      spotLight.penumbra = 0.2;',
      '      spotLight.decay = 2;',
      '      spotLight.distance = 10;',
      '      spotLight.castShadow = true;',
      '      spotLight.shadow.mapSize.width = 1024;',
      '      spotLight.shadow.mapSize.height = 1024;',
      '      this.scene.add(spotLight);',
      '',
      '      // Target for spotlight',
      '      const targetObject = new THREE.Object3D();',
      '      targetObject.position.set(i, 1, -1);',
      '      this.scene.add(targetObject);',
      '      spotLight.target = targetObject;',
      '    }',
      '  }',
      '',
      '  loadGalleryModel() {',
      '    const loader = new GLTFLoader();',
      '    loader.load(',
      '      "/models/gallery.glb",',
      '      (gltf) => {',
      '        const model = gltf.scene;',
      '        model.traverse((child) => {',
      '          if (child.isMesh) {',
      '            child.castShadow = true;',
      '            child.receiveShadow = true;',
      '          }',
      '        });',
      '        this.scene.add(model);',
      '        this.loadArtworks();',
      '      },',
      '      (xhr) => {',
      '        console.log((xhr.loaded / xhr.total) * 100 + "% loaded");',
      '      },',
      '      (error) => {',
      '        console.error("An error happened loading the gallery model:", error);',
      '      }',
      '    );',
      '  }',
      '',
      '  loadArtworks() {',
      '    // Load artwork data and create planes with textures',
      '    fetch("/api/artworks")',
      '      .then(response => response.json())',
      '      .then(artworksData => {',
      '        const textureLoader = new THREE.TextureLoader();',
      '        ',
      '        artworksData.forEach((artwork, index) => {',
      '          const texture = textureLoader.load(artwork.imageUrl);',
      '          texture.encoding = THREE.sRGBEncoding;',
      '',
      '          // Calculate aspect ratio to maintain image proportions',
      '          const aspectRatio = artwork.width / artwork.height;',
      '          const width = 1.5;',
      '          const height = width / aspectRatio;',
      '',
      '          // Create frame material',
      '          const frameMaterial = new THREE.MeshStandardMaterial({',
      '            color: 0x222222,',
      '            metalness: 0.5,',
      '            roughness: 0.2',
      '          });',
      '',
      '          // Create artwork material',
      '          const artworkMaterial = new THREE.MeshStandardMaterial({',
      '            map: texture,',
      '            emissive: 0xffffff,',
      '            emissiveMap: texture,',
      '            emissiveIntensity: 0.2',
      '          });',
      '',
      '          // Create frame',
      '          const frameWidth = width + 0.1;',
      '          const frameHeight = height + 0.1;',
      '          const frameDepth = 0.05;',
      '          const frameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);',
      '          const frame = new THREE.Mesh(frameGeometry, frameMaterial);',
      '',
      '          // Create artwork plane',
      '          const artworkGeometry = new THREE.PlaneGeometry(width, height);',
      '          const artworkPlane = new THREE.Mesh(artworkGeometry, artworkMaterial);',
      '          artworkPlane.position.z = frameDepth / 2 + 0.001;',
      '          frame.add(artworkPlane);',
      '',
      '          // Position the frame on the wall',
      '          const spacing = 2;',
      '          frame.position.set(-3 + index * spacing, 1.5, -1);',
      '          frame.rotation.y = 0;',
      '',
      '          // Add metadata to the frame for interaction',
      '          frame.userData = {',
      '            type: "artwork",',
      '            id: artwork.id,',
      '            title: artwork.title,',
      '            artist: artwork.artist,',
      '            description: artwork.description,',
      '            price: artwork.price',
      '          };',
      '',
      '          this.scene.add(frame);',
      '          this.artworks.push(frame);',
      '        });',
      '      })',
      '      .catch(error => {',
      '        console.error("Error loading artworks:", error);',
      '      });',
      '  }',
      '',
      '  onWindowResize() {',
      '    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;',
      '    this.camera.updateProjectionMatrix();',
      '    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);',
      '    this.composer.setSize(this.container.clientWidth, this.container.clientHeight);',
      '  }',
      '',
      '  onMouseMove(event) {',
      '    // Calculate mouse position in normalized device coordinates',
      '    const rect = this.container.getBoundingClientRect();',
      '    this.mouse.x = ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1;',
      '    this.mouse.y = -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1;',
      '',
      '    // Perform raycasting to detect hover over artworks',
      '    this.raycaster.setFromCamera(this.mouse, this.camera);',
      '    const intersects = this.raycaster.intersectObjects(this.artworks, true);',
      '',
      '    if (intersects.length > 0) {',
      '      const object = intersects[0].object.parent || intersects[0].object;',
      '      if (object.userData.type === "artwork") {',
      '        this.container.style.cursor = "pointer";',
      '      }',
      '    } else {',
      '      this.container.style.cursor = "default";',
      '    }',
      '  }',
      '',
      '  onMouseClick(event) {',
      '    // Calculate mouse position in normalized device coordinates',
      '    const rect = this.container.getBoundingClientRect();',
      '    this.mouse.x = ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1;',
      '    this.mouse.y = -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1;',
      '',
      '    // Perform raycasting to detect clicks on artworks',
      '    this.raycaster.setFromCamera(this.mouse, this.camera);',
      '    const intersects = this.raycaster.intersectObjects(this.artworks, true);',
      '',
      '    if (intersects.length > 0) {',
      '      const object = intersects[0].object.parent || intersects[0].object;',
      '      if (object.userData.type === "artwork") {',
      '        this.selectedArtwork = object.userData;',
      '        if (this.onArtworkSelected) {',
      '          this.onArtworkSelected(this.selectedArtwork);',
      '        }',
      '      }',
      '    }',
      '  }',
      '',
      '  animate() {',
      '    requestAnimationFrame(this.animate.bind(this));',
      '    const delta = this.clock.getDelta();',
      '    this.controls.update();',
      '    this.composer.render();',
      '  }',
      '',
      '  setArtworkSelectedCallback(callback) {',
      '    this.onArtworkSelected = callback;',
      '  }',
      '',
      '  dispose() {',
      '    // Clean up resources when component unmounts',
      '    window.removeEventListener("resize", this.onWindowResize.bind(this));',
      '    this.container.removeEventListener("click", this.onMouseClick.bind(this));',
      '    this.container.removeEventListener("mousemove", this.onMouseMove.bind(this));',
      '    this.renderer.dispose();',
      '  }',
      '}'
    ],
    codeLanguage: 'javascript',
    features: [
      'Immersive 3D virtual gallery environments',
      'Interactive artwork displays',
      'Virtual exhibition creation tools',
      'Artist profiles and portfolios',
      'Integrated e-commerce for art purchases'
    ]
  },

  {
    title: 'MindfulAI',
    description: 'A mental health and wellness application that uses AI to provide personalized meditation, stress management, and mood tracking. Features include guided sessions, progress analytics, and community support.',
    image: '/projects/project1.png',
    technologies: ['React Native', 'TensorFlow.js', 'Firebase', 'Node.js', 'Express'],
    github: 'https://github.com/yourusername/mindfulai',
    live: 'https://mindfulai.vercel.app',
    category: 'AI & Healthcare',
    codeSnippet: [
      'import React, { useState, useEffect } from "react";',
      'import { View, Text, StyleSheet, Animated, Easing } from "react-native";',
      'import { Audio } from "expo-audio";',
      'import { LinearGradient } from "expo-linear-gradient";',
      'import { useSelector, useDispatch } from "react-redux";',
      'import { updateMeditationStats } from "../redux/actions/userActions";',
      'import { BreathingCircle, Timer, BackgroundSounds } from "../components";',
      'import { hapticFeedback } from "../utils/haptics";',
      '',
      'const MeditationSession = ({ route, navigation }) => {',
      '  const { sessionType, duration, guidedAudioUrl, backgroundSound } = route.params;',
      '  const dispatch = useDispatch();',
      '  const user = useSelector(state => state.user);',
      '  ',
      '  // Animation values',
      '  const breatheAnim = new Animated.Value(0);',
      '  const fadeAnim = new Animated.Value(0);',
      '  ',
      '  // Session state',
      '  const [isActive, setIsActive] = useState(false);',
      '  const [isPaused, setIsPaused] = useState(false);',
      '  const [timeRemaining, setTimeRemaining] = useState(duration * 60);',
      '  const [breathingPhase, setBreathingPhase] = useState("inhale");',
      '  const [breathingPattern, setBreathingPattern] = useState({',
      '    inhale: 4,',
      '    hold1: 2,',
      '    exhale: 6,',
      '    hold2: 2',
      '  });',
      '  const [guidedAudio, setGuidedAudio] = useState(null);',
      '  const [backgroundAudio, setBackgroundAudio] = useState(null);',
      '',
      '  // Initialize session',
      '  useEffect(() => {',
      '    // Fade in animation',
      '    Animated.timing(fadeAnim, {',
      '      toValue: 1,',
      '      duration: 1000,',
      '      useNativeDriver: true',
      '    }).start();',
      '    ',
      '    // Load audio files',
      '    if (guidedAudioUrl) {',
      '      loadGuidedAudio();',
      '    }',
      '    ',
      '    if (backgroundSound) {',
      '      loadBackgroundSound();',
      '    }',
      '    ',
      '    // Start session after a brief delay',
      '    const timer = setTimeout(() => {',
      '      startSession();',
      '    }, 2000);',
      '    ',
      '    return () => {',
      '      clearTimeout(timer);',
      '      cleanupAudio();',
      '    };',
      '  }, []);',
      '',
      '  // Breathing animation cycle',
      '  useEffect(() => {',
      '    if (!isActive) return;',
      '    ',
      '    const totalCycleDuration = ',
      '      breathingPattern.inhale + ',
      '      breathingPattern.hold1 + ',
      '      breathingPattern.exhale + ',
      '      breathingPattern.hold2;',
      '    ',
      '    const breathingSequence = () => {',
      '      // Inhale animation',
      '      setBreathingPhase("inhale");',
      '      hapticFeedback("light");',
      '      ',
      '      Animated.timing(breatheAnim, {',
      '        toValue: 1,',
      '        duration: breathingPattern.inhale * 1000,',
      '        easing: Easing.cubic,',
      '        useNativeDriver: false',
      '      }).start(() => {',
      '        // First hold',
      '        setBreathingPhase("hold");',
      '        hapticFeedback("medium");',
      '        ',
      '        setTimeout(() => {',
      '          // Exhale animation',
      '          setBreathingPhase("exhale");',
      '          hapticFeedback("light");',
      '          ',
      '          Animated.timing(breatheAnim, {',
      '            toValue: 0,',
      '            duration: breathingPattern.exhale * 1000,',
      '            easing: Easing.cubic,',
      '            useNativeDriver: false',
      '          }).start(() => {',
      '            // Second hold',
      '            setBreathingPhase("rest");',
      '            hapticFeedback("medium");',
      '            ',
      '            setTimeout(breathingSequence, breathingPattern.hold2 * 1000);',
      '          });',
      '        }, breathingPattern.hold1 * 1000);',
      '      });',
      '    };',
      '    ',
      '    breathingSequence();',
      '    ',
      '    return () => {',
      '      breatheAnim.stopAnimation();',
      '    };',
      '  }, [isActive, breathingPattern]);',
      '',
      '  // Timer countdown',
      '  useEffect(() => {',
      '    if (!isActive || isPaused) return;',
      '    ',
      '    const interval = setInterval(() => {',
      '      setTimeRemaining(prev => {',
      '        if (prev <= 1) {',
      '          completeSession();',
      '          clearInterval(interval);',
      '          return 0;',
      '        }',
      '        return prev - 1;',
      '      });',
      '    }, 1000);',
      '    ',
      '    return () => clearInterval(interval);',
      '  }, [isActive, isPaused]);',
      '',
      '  const loadGuidedAudio = async () => {',
      '    try {',
      '      const { sound } = await Audio.Sound.createAsync(',
      '        { uri: guidedAudioUrl },',
      '        { shouldPlay: false, isLooping: false }',
      '      );',
      '      setGuidedAudio(sound);',
      '    } catch (error) {',
      '      console.error("Error loading guided audio:", error);',
      '    }',
      '  };',
      '',
      '  const loadBackgroundSound = async () => {',
      '    try {',
      '      const { sound } = await Audio.Sound.createAsync(',
      '        backgroundSound.source,',
      '        { shouldPlay: false, isLooping: true, volume: 0.4 }',
      '      );',
      '      setBackgroundAudio(sound);',
      '    } catch (error) {',
      '      console.error("Error loading background sound:", error);',
      '    }',
      '  };',
      '',
      '  const startSession = async () => {',
      '    setIsActive(true);',
      '    ',
      '    if (guidedAudio) {',
      '      try {',
      '        await guidedAudio.playAsync();',
      '      } catch (error) {',
      '        console.error("Error playing guided audio:", error);',
      '      }',
      '    }',
      '    ',
      '    if (backgroundAudio) {',
      '      try {',
      '        await backgroundAudio.playAsync();',
      '      } catch (error) {',
      '        console.error("Error playing background sound:", error);',
      '      }',
      '    }',
      '  };',
      '',
      '  const pauseSession = async () => {',
      '    setIsPaused(true);',
      '    ',
      '    if (guidedAudio) {',
      '      await guidedAudio.pauseAsync();',
      '    }',
      '    ',
      '    if (backgroundAudio) {',
      '      await backgroundAudio.pauseAsync();',
      '    }',
      '  };',
      '',
      '  const resumeSession = async () => {',
      '    setIsPaused(false);',
      '    ',
      '    if (guidedAudio) {',
      '      await guidedAudio.playAsync();',
      '    }',
      '    ',
      '    if (backgroundAudio) {',
      '      await backgroundAudio.playAsync();',
      '    }',
      '  };',
      '',
      '  const completeSession = async () => {',
      '    setIsActive(false);',
      '    cleanupAudio();',
      '    ',
      '    // Update user stats',
      '    const sessionData = {',
      '      date: new Date().toISOString(),',
      '      duration: duration,',
      '      type: sessionType',
      '    };',
      '    ',
      '    dispatch(updateMeditationStats(sessionData));',
      '    ',
      '    // Navigate to completion screen',
      '    navigation.replace("SessionComplete", {',
      '      duration,',
      '      sessionType',
      '    });',
      '  };',
      '',
      '  const cleanupAudio = async () => {',
      '    if (guidedAudio) {',
      '      await guidedAudio.stopAsync();',
      '      await guidedAudio.unloadAsync();',
      '    }',
      '    ',
      '    if (backgroundAudio) {',
      '      await backgroundAudio.stopAsync();',
      '      await backgroundAudio.unloadAsync();',
      '    }',
      '  };',
      '',
      '  return (',
      '    <LinearGradient',
      '      colors={["#1a2151", "#0d1128"]}',
      '      style={styles.container}',
      '    >',
      '      <Animated.View style={[styles.content, { opacity: fadeAnim }]}>',
      '        <Text style={styles.phaseText}>',
      '          {breathingPhase === "inhale" ? "Breathe In" :',
      '           breathingPhase === "hold" ? "Hold" :',
      '           breathingPhase === "exhale" ? "Breathe Out" : "Rest"}',
      '        </Text>',
      '        ',
      '        <BreathingCircle ',
      '          animValue={breatheAnim}',
      '          phase={breathingPhase}',
      '        />',
      '        ',
      '        <Timer ',
      '          timeRemaining={timeRemaining}',
      '          isPaused={isPaused}',
      '          onPause={pauseSession}',
      '          onResume={resumeSession}',
      '          onEnd={completeSession}',
      '        />',
      '      </Animated.View>',
      '    </LinearGradient>',
      '  );',
      '};',
      '',
      'const styles = StyleSheet.create({',
      '  container: {',
      '    flex: 1,',
      '    justifyContent: "center",',
      '    alignItems: "center"',
      '  },',
      '  content: {',
      '    alignItems: "center",',
      '    justifyContent: "center",',
      '    width: "100%"',
      '  },',
      '  phaseText: {',
      '    fontSize: 24,',
      '    color: "#ffffff",',
      '    marginBottom: 40,',
      '    fontFamily: "Poppins-Medium"',
      '  }',
      '});',
      '',
      'export default MeditationSession;'  
    ],
    codeLanguage: 'javascript',
    features: [
      'AI-powered personalized meditation',
      'Stress and anxiety management tools',
      'Mood tracking and analytics',
      'Guided breathing exercises',
      'Community support and challenges'
    ],
    screenshots: [
      '/projects/project2.png',
      '/projects/project4.png'
    ]
  }
];

// Export all projects combined
export const allProjects = [
  ...additionalProjects
];
